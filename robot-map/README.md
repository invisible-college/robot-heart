# Robot Map

Lead Teacher and App Designer: Adrian Laurenzi

The second part of the course, Robot Map will give you practice in creating a simple
map-based app that uses your current location as input, displays geographical information
on a map, and can tag virtual objects with this location.

# Table of Contents
1. [Basic setup of Mapbox SDK](#basic-setup-of-mapbox-sdk)
2. [Basic setup of Google Maps SDK](#basic-setup-for-google-maps-sdk)
3. [Displaying user's location on map](#displaying-users-location-on-map)
4. [Map data](#map-data)
5. [Displaying saved data on the map](displaying-saved-data-on-the-map)
6. [Going further](#going-further)

### Basic setup of Mapbox SDK

We start with the default project structure generated when starting a new project with Android Studio (ensure minSdkVersion is 15).

Our first task is to get a hold of the Mapbox Android SDK and get it set up to display in our app. Setup instructions and SDK docs are found [here on the Mapbox website](https://www.mapbox.com/android-sdk/).

Following the instructions for setting up the [mapbox-sdk using Gradle](https://www.mapbox.com/android-sdk/#gradle), you can include the SDK as a dependency of the app. To do this simply add this code to the `app/build.gradle` file:

```
repositories {
    mavenCentral()
}

dependencies {
    compile ('com.mapbox.mapboxsdk:mapbox-android-sdk:2.2.0@aar'){
        transitive=true
    }
}
```

Next you must add the appropriate user permissions to the `AndroidManifest.xml` file (these permissions are required to allow grabbing the map data to display from a remote host):

```xml
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
<uses-permission android:name="android.permission.INTERNET" />
```

To include a map in your app you first need to sign up for a Mapbox account at [mapbox.com](https://www.mapbox.com/studio/signup/?path=%2Fstudio%2Faccount%2Fapps) to get your access token which is required to use the Mapbox APIs used to display the map. 

Once you have an access token you can add the MapView XML to the activity layout in `res/layout/activity_mapbox_map.xml`:

```xml
<com.mapbox.mapboxsdk.views.MapView
android:id="@+id/mapview"
android:layout_width="fill_parent"
android:layout_height="fill_parent"
mapbox:access_token="<your access token here>"/>
```

Now you can programatically access the MapView to configure it in the onCreate method of the Activity by adding the following inside onCreate:

```java
MapView mapView = (MapView) findViewById(R.id.mapboxMapView);
mapView.setStyleUrl(Style.MAPBOX_STREETS);
mapView.setCenterCoordinate(new LatLng(47.605967, -122.334539));
mapView.setZoomLevel(11);
mapView.onCreate(savedInstanceState);
```

This initializes the map with the Mapbox Streets styling and sets the center of the map on Seattle, WA.


### Basic setup for Google Maps SDK

The process of getting a Google Map set up is similar to that described above for the Mapbox SDK. The first step is to use Android Studio to create a new Google Maps Activity by going to File > New > Activity > Google > Google Maps Activity. Next you must get a Google API Key by following these steps:

1. Copy the link provided in the `google_maps_api.xml` file and paste it into your browser. The link takes you to the Google Developers Console and supplies information via URL parameters, thus reducing the manual input required from you.
2. Follow the instructions to create a new project on the console or select an existing project.
3. Create an Android API key for your console project.
4. Copy the resulting API key, go back to Android Studio, and paste the API key into the <string> element in the google_maps_api.xml file. 

It is nifty that Android Studio automatically generates the code required for the Google Map. Noticed what code was changed:

1. Added Google Play Services as a dependency in `app/build.gradle`
2. READ_GSERVICES as a new user permission in the `AndroidManifest.xml`
3. `GoogleMapsActivity.java` and `activity_google_maps.xml`
4. Two `google_maps_api.xml` files (one storing the development/debug API Key and another for the release version which you dont yet need to fill in)

The code generated by Android Studio in `GoogleMapsActivity.java` should be replaced by this code:

```java
package org.invisiblecollege.robotmap;

import android.support.v4.app.FragmentActivity;
import android.os.Bundle;

import com.google.android.gms.maps.CameraUpdateFactory;
import com.google.android.gms.maps.GoogleMap;
import com.google.android.gms.maps.OnMapReadyCallback;
import com.google.android.gms.maps.SupportMapFragment;
import com.google.android.gms.maps.model.LatLng;

public class GoogleMapsActivity extends FragmentActivity implements OnMapReadyCallback {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_google_maps);
        SupportMapFragment mapFragment = (SupportMapFragment) getSupportFragmentManager()
                .findFragmentById(R.id.map);
        mapFragment.getMapAsync(this);
    }

    @Override
    public void onMapReady(GoogleMap map) {
        // Center the map on Seattle, WA
        map.moveCamera(CameraUpdateFactory.newLatLng(new LatLng(47.605967, -122.334539)));
    }
}
```

This set up the map centered on Seattle, WA.

More detailed information on getting set up with the Google Maps SDK is in the [Getting Started guide here](https://developers.google.com/maps/documentation/android-api/start). 

Now lets view the map! But first we must change the default Activity from the MapboxMapActivity to the GoogleMapActivity by moving the intent filter code from inside the MapboxMapActivity XML block to that for the GoogleMapsActivity. So now the code in `looks like this in `AndroidManifest.xml`.

```xml
<activity
    android:name=".GoogleMapsActivity"
    android:label="@string/title_activity_google_maps" >
    <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
    </intent-filter>
</activity>

<activity
    android:name=".MapboxMapActivity"
    android:label="@string/app_name" >
</activity>
```

Run the application and you should see the Google Map that looks very similar to the Mapbox one but with the Google logo in the bottom left corner.


### Displaying user's location on map

In order to track a user's location we must add the following user permissions to `AndroidManifest.xml`:

```xml
<uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
```

The simplest way to display the user's location on the map is to use the build-in Mapbox SDK function. Simply add this line of code to `MapboxMapActivity.java`'s onCreate method to track and display user location on the map:

```java
mapView.setMyLocationEnabled(true);
```

Then you can set Mapbox to either continuously track and update the user's location or disable tracking by calling `mapView.setMyLocationTrackingMode(..)`. This call does a number of things behind the scenes with the Android Location APIs. You should understand that there are multiple possible ways your phone can determine your location, which vary in terms of accuracy. Under the hood the Mapbox SDK makes use of the [LocationRequest](http://developer.android.com/reference/com/google/android/gms/location/LocationRequest.html) class to get user location updates. For more fine-grained control of location updates refer to [this documentation](http://developer.android.com/training/location/receive-location-updates.html).


### Location updates and battery usage

Requesting location updates can have a significant impact on the power consumption caused by your app. Basically, the more often location updates are requested the more battery your app will consume. Also different location provider have different impacts, and in general the more precise the provider the more power is consumed per update.

By default the Mapbox SDK will continuously request location updates which can make a significant impact on the power consumption of your app. You can disable location updates using the following code:

```java
mapView.setMyLocationTrackingMode(MyLocationTracking.TRACKING_NONE);
```

There are various ways to reduce the power consumption of requesting the user's location. One such method is to use the low-power mode when issuing a [LocationRequest](http://developer.android.com/training/location/receive-location-updates.html#location-request) to update the user's Location. 


### Map data

So far there is only one data source powering each map in our app. It is the tile layer provided by the Mapbox API called Mapbox Streets in the Mapbox and Google Maps API for the Google Map. In the case of Mapbox Streets the data is stored as vector tiles meaning the map data is stored as a vectors rather than a rendered image (traditional web map format). You can read about this [open specification here](https://github.com/mapbox/vector-tile-spec). Map data is more limited in vector tile format but this is a more efficient means of displaying maps because less data is downloaded from the server (vector data is smaller than image data).  The latest Mapbox SDK (2.2) only allows using vector tile data. The Google Maps SDK, however, supports using image tiles so next we will show how to hook up the app to display Open Street Map (OSM) tiles hosted for free by the OSM community. 

The OSM community maintains a [list of tile servers here](http://wiki.openstreetmap.org/wiki/Tile_servers). To emphasize how much map styling can very lets hook up outdoor-focused map tiles that includes topographic and trail data from 'Thunderforest Outdoors'. You just need to copy one of the tile URLs from that column for the Thunderforest Outdoors (any of the servers a, b, or c will work), so lets use a: `http://a.tile.thunderforest.com/outdoors/${z}/${x}/${y}.png`. ${z}, ${x}, and ${y} each represent the coordinates of a given map tile which is just a normal raster image. To add this as a tile source for the Google Map we use a [TileOverlay](https://developers.google.com/maps/documentation/android-api/tileoverlay). 

Add this code to the onMapReady method in `GoogleMapActivity.java` to have the map render the OSM tiles:

```java
// Clears default Google Map tiles
map.setMapType(GoogleMap.MAP_TYPE_NONE);

TileProvider tileProvider = new UrlTileProvider(256, 256) {
    @Override
    public synchronized URL getTileUrl(int x, int y, int zoom) {
        String s = String.format("http://a.tile.thunderforest.com/outdoors/%d/%d/%d.png", zoom, x, y);
        URL url = null;
        try {
            url = new URL(s);
        } catch (MalformedURLException e) {
            throw new AssertionError(e);
        }
        return url;
    }
};
// Adds the OSM map tiles
map.addTileOverlay(new TileOverlayOptions().tileProvider(tileProvider));
```

Another cool set of map tiles are those maintained by the [Humanitarian OSM Team](https://hotosm.org/), also linked on the OSM wiki of tile sources. As you can see the community did a lot of work mapping important services in response to the catastrophic earthquake in Nepal. Preview [those tiles here](http://www.openstreetmap.org/relation/4583125#map=13/27.7013/85.3332&layers=H). 

Its worth noting that Google Map tiles are not fully open source, you are only allowed to use their tiles with their SDKs. Mapbox, on the other hand, provides direct access to all of their fully open source map tiles. You can also use tools like [Mapbox Studio](https://www.mapbox.com/mapbox-studio/) to create custom-styled map tiles.


### Displaying saved data on the map

We are going to enable the user to save pins to track their location as they move. So we will first create a button that, upon being tapped, drops a pin on the map at the users current location (the pin will also display the latitude and longitude of the given location). Since we will do this on the Mapbox Map, we add the button XML to `activity_mapbox_map.xml`:

```xml
<Button
    android:id="@+id/saveLocationButton"
    android:layout_height="wrap_content"
    android:layout_width="wrap_content"
    android:text="Save My Location" />
```

Next we add a listener in the onCreate method of `MapboxMapActivity.java`:

```java
final Button button = (Button) findViewById(R.id.saveLocationButton);
button.setOnClickListener(new View.OnClickListener() {
    public void onClick(View v) {
        Location myLocation = mapView.getMyLocation();
        addPointToMap(new LatLng(myLocation.getLatitude(), myLocation.getLongitude()));
    }
});
```

The code for the addPointToMap method, which adds a marker on the Mapbox map, is:

```java
private void addPointToMap(LatLng locationToAdd) {
    String latLngAsString = locationToAdd.getLatitude() + "," + locationToAdd.getLongitude();
    mapView.addMarker(new MarkerOptions()
            .position(new LatLng(locationToAdd.getLatitude(), locationToAdd.getLongitude()))
            .title(latLngAsString));
}
```

So far the user has the ability to drop pins as their location changes but if they quit the app all this data will be lost (the points are only stored in thus far RAM). We want to save these locations persistently so that means saving it to local storage on the device. There are [various options](http://developer.android.com/guide/topics/data/data-storage.html) to save data with Android, in this case we want our data to be structured so the best option is use to [SQLite](http://developer.android.com/training/basics/data-storage/databases.html).

To save user data persistently (and then retrieve at any time to display on a map) we will write lat/lng points when the user taps the 'Save My Location' button. To do this cleanly, we can create a helper called `SavedPointsHelper.java` which manages all the interaction with the database:

```java
public class SavedPointsHelper extends SQLiteOpenHelper {

    private static final String DATABASE_NAME = "robotmap";

    private static final int DATABASE_VERSION = 1;
    private static final String POINTS_TABLE_NAME = "points";

    private static final String POINT_ID = "point_id";
    private static final int POINT_ID_INDEX = 0;
    private static final String POINT_LAT = "point_lat";
    private static final int POINT_LAT_INDEX = 1;
    private static final String POINT_LNG = "point_lng";
    private static final int POINT_LNG_INDEX = 2;

    private static final String POINTS_TABLE_CREATE =
            "CREATE TABLE " + POINTS_TABLE_NAME + "("
                    + POINT_ID + " INTEGER PRIMARY KEY AUTOINCREMENT,"
                    + POINT_LAT + " REAL,"
                    + POINT_LNG + " REAL" + ")";

    public SavedPointsHelper(Context context) {
        super(context, DATABASE_NAME, null, DATABASE_VERSION);
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
        db.execSQL(POINTS_TABLE_CREATE);
    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        // Drop older table if existed
        db.execSQL("DROP TABLE IF EXISTS " + POINTS_TABLE_NAME);

        // Create tables again
        onCreate(db);
    }

    public void saveNewPoint(final double lat, final double lng) {
        SQLiteDatabase db = this.getWritableDatabase();
        ContentValues values = new ContentValues();
        values.put(POINT_LAT, lat);
        values.put(POINT_LNG, lng);
        db.insert(POINTS_TABLE_NAME, null, values);
        db.close();
    }

    public List<LatLng> getSavedPoints() {
        List<LatLng> points = new ArrayList<>();
        String selectQuery = "SELECT  * FROM " + POINTS_TABLE_NAME;

        SQLiteDatabase db = this.getReadableDatabase();
        Cursor cursor = db.rawQuery(selectQuery, null);

        if (cursor.moveToFirst()) {
            do {
                LatLng point = getPointFromDbRow(cursor);
                points.add(point);
            } while (cursor.moveToNext());
        }
        db.close();
        return points;
    }

    private LatLng getPointFromDbRow(Cursor cursor) {
        double lat = cursor.getDouble(POINT_LAT_INDEX);
        double lng = cursor.getDouble(POINT_LNG_INDEX);
        return new LatLng(lat, lng);
    }
}
```

In the onCreate method of `MapboxMapActivity.java` we can initialize the helper with `savedPointsHelper = new SavedPointsHelper(this);`. Then to display all saved points we create this method, which we can call in onCreate or anywhere else we like:

```java
private void showAllSavedPoints() {
    List<LatLng> savedPoints = savedPointsHelper.getSavedPoints();
    for (LatLng point : savedPoints) {
        addPointToMap(point);
    }
}
```

Finally we add a line to the button's onClickListener to actually save the lat/lng point of the user's current location to the SQLite database:

```java
Location myLocation = mapView.getMyLocation();
savedPointsHelper.saveNewPoint(myLocation.getLatitude(), myLocation.getLongitude());
```


### Going further

- Allow the user to save an image from built-in camera and associate the picture with a point. Refer to this guide to use the [built-in camera](http://developer.android.com/training/camera/photobasics.html) to take photots and save them for display on the map. You will need to find a way to link the point data in the SQLite database with the saved image file (hint: each record in the SQLite database table is assigned a unique ID `point_id`).


- To style your own Mapbox map with Mapbox Studio and display your custom-styled map in your app. You can first create a new Style using the [Mapbox Studio](https://www.mapbox.com/mapbox-studio/) web application and then copy the style URL (looks something like `mapbox://styles/your_username/cihm7bjhv001b93kmi2mzoysi`), then input it into the setStyleUrl method call in onCreate of `MapboxMapActivity.java` like this: `mapView.setStyleUrl("mapbox://styles/your_username/cihm7bjhv001b93kmi2mzoysi");`

